<h1>Лабораторная №2 (со звездочкой)</h1>

<h3>Задание:</h3>

<ol>
  <li>Написать “плохой” Docker compose файл, в котором есть не менее трех “bad practices” по их написанию.</li>
  <li>Написать “хороший” Docker compose файл, в котором эти плохие практики исправлены.</li>
  <li>В Readme описать каждую из плохих практик в плохом файле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат.</li>
  <li>После предыдущих пунктов в хорошем файле настроить сервисы так, чтобы контейнеры в рамках этого compose-проекта так же поднимались вместе, но не "видели" друг друга по сети. В отчете описать, как этого добились и кратко объяснить принцип такой изоляции.</li>
</ol>

<h2>Ход работы</h2>

В лабораторной работе создадим Docker-compose, в котором будет Dockerfile приложения на Python и сервиса кэширования веб-страницы Redis. Так наш файл будет содержать 4 файла:
1. app.py — python-файл, в котором мы создаем ту самую веб-страницу с счетчиком ~~тапания хомяка~~ обновления страницы
2. Dockerfile — доверфайл для нашего приложения на python
3. requirements.txt — файл, который задает необходимые библиотеки и их версии в Dockerfile
4. docker-compose.yml — тот самый файл, ради которого мв разбирались во flask и redis, чтобы обернуть их в один контейнер
   
Заметим, что для redis не обязательно писать свой Docker, так как мы будем использовать официальный образ Docker Hub. Здесь то мы и рассмотрим хорошие и плохие практики при работе с docker-compose.

<h3>0. Использование версий</h3>
Плохая практика: 

```
version: '3.3'
```
Хорошая практика: 

```
version: '3.9'
```
<h5>Почему:</h5> Не стоит использовать старые версии docker-compose, так как это ограничивает большое количество возможностей файла. Интересный факт, но когда мы пытались написать плохой файл, мы сломали его 2 версией, которая наотрез отказывалась собирать контейнер с нашим стеком

<h3>1. Использование переменных окружения</h3>
Плохая практика: 

```
//А тут пусто и никакого полезного кода
```
Хорошая практика: 

```
environment:
      - REDIS_HOST=redis
```

<h5>Почему:</h5> Использование переменных окружения делает приложение более гибким, что позволяет проще изменять конфигурацию приложения в различных средах. Также это делает приложение безопаснее, потому что хранить конфиденциальную информацию лучше именно в переменных окружения.

<h3>2. Использование пользовательской сети</h3>
Плохая практика: 

```
//Опять ничего
```
Хорошая практика: 

```
networks:
      - app-network
```
<h5>Почему:</h5> Пользовательская сеть позволяет изолировать контейнеры друг от друга и позволяет им безопасно взаимодействовать через организованную архитектуру.

<h3>3. Использование проверок состояния</h3>
Плохая практика: 

```
//...
```
Хорошая практика: 

```
healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:5000/"]
      interval: 30s
      timeout: 10s
      retries: 5
```
<h5>Почему:</h5> Проверка состояния веб-сервиса позволяет проверять доступность URL и автоматически перезапускать контейнеры при их выходе из строя. Благодаря этому становится проще отслеживать состояник приложения и обеспечивать его доступность.

Вот так при запуске контейнера мы собрали приложение по тапанию хомяка через обновление страницы:
![image](https://github.com/user-attachments/assets/d0724a6f-f332-407b-8921-5802a1787f48)
![image](https://github.com/user-attachments/assets/6c85112c-e130-4f72-ad62-db116f4a8166)

Далее необходимо еще немного повозиться с хорошим файлом и настроить сервисы так, чтобы контейнеры в рамках этого compose-проекта так же поднимались вместе, но не "видели" друг друга по сети.

